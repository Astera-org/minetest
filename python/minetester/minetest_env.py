import datetime
import logging
import os
import shutil
import socket
import subprocess
import time
import uuid
from collections import namedtuple
from pathlib import Path
from typing import Any, Dict, Optional, Tuple

import capnp
import gymnasium as gym
import numpy as np
import zmq

try:
    import pygame
except ImportError:
    pygame = None

remoteclient_capnp = capnp.load(
    os.path.join(os.path.dirname(__file__), "proto/remoteclient.capnp")
)


# Define default keys / buttons
KEY_MAP = [
    "forward",
    "left",
    "backward",
    "right",
    "jump",
    "sneak",
    "dig",
    "place",
    "cameraMode",
]

INVERSE_KEY_MAP = {name: idx for idx, name in enumerate(KEY_MAP)}

DisplaySize = namedtuple("DisplaySize", ["width", "height"])

_still_loading_colors = (
    np.array([59, 59, 59], dtype=np.uint8),
    np.array([58, 58, 58], dtype=np.uint8),
    np.array([57, 57, 57], dtype=np.uint8),
)


def _is_loading(obs) -> bool:
    # Best way I've thought of to deal with this is to check if the image is
    # mostly the particular color.
    return any(
        (obs == color).all(axis=2).mean() > 0.5 for color in _still_loading_colors
    )


class MinetestEnv(gym.Env):
    metadata = {"render_modes": ["rgb_array", "human"]}

    def __init__(
        self,
        minetest_executable: Optional[os.PathLike] = "minetest",
        world_dir: Optional[os.PathLike] = None,
        artifact_dir: Optional[os.PathLike] = None,
        config_path: Optional[os.PathLike] = None,
        zmq_host: str = "127.0.0.1",
        zmq_port: Optional[int] = None,
        display_size: Tuple[int, int] = (600, 400),
        render_mode: str = "rgb_array",
        game_dir: Optional[os.PathLike] = None,
        fov: int = 72,
        base_seed: int = 0,
        world_seed: Optional[int] = None,
        config_dict: Dict[str, Any] = None,
        headless: bool = True,
        verbose_logging: bool = False,
    ):
        if config_dict is None:
            config_dict = {}
        self.unique_env_id = str(uuid.uuid4())

        self.display_size = DisplaySize(*display_size)
        self.fov_y = fov
        self.fov_x = self.fov_y * self.display_size.width / self.display_size.height
        self.render_mode = render_mode
        self.headless = headless
        self.game_dir = game_dir
        if not ((zmq_host and zmq_port) or game_dir or world_dir):
            raise ValueError(
                "Either zmq_host and zmq_port or game_dir or a world_dir must be provided!"
            )

        if render_mode == "human":
            self._start_pygame()

        # Define action and observation space
        self._configure_spaces()

        # Define Minetest paths
        self._set_artifact_dirs(
            artifact_dir, world_dir, config_path
        )  # Stores minetest artifacts and outputs
        if minetest_executable:
            self.minetest_executable = Path(minetest_executable)
            assert shutil.which(
                self.minetest_executable
            ), f"minetest_executable not found: {self.minetest_executable}"
        else:
            self.minetest_executable = None
            logging.debug(
                "minetest_executable not specified, will attempt to connect "
                "to running minetest instance."
            )
            if not (zmq_host and zmq_port):
                raise ValueError(
                    "if minetest_executable not specified, zmq_host and zmq_port must be"
                )

        # ZMQ port
        if zmq_host == "localhost":
            zmq_host = "127.0.0.1"  # see https://stackoverflow.com/questions/6024003/why-doesnt-zeromq-work-on-localhost
        self.zmq_socket_addr = f"{zmq_host}:{zmq_port or get_free_port()}"
        self.verbose_logging = verbose_logging

        # ZMQ objects
        self.socket = None
        self.context = None

        # Minetest processes
        self.client_process = None

        # Env objects
        self.last_obs = None
        self.render_fig = None
        self.render_img = None

        # Seed the environment
        self.base_seed = base_seed
        self.world_seed = world_seed
        # If no world_seed is provided
        # seed the world with a random seed
        # generated by the RNG from base_seed
        self.reseed_on_reset = world_seed is None
        self.seed(self.base_seed)

        # Write minetest.conf
        self.config_dict = config_dict
        self._write_config()

        # Configure logging
        logging.basicConfig(
            filename=os.path.join(self.log_dir, f"env_{self.unique_env_id}.log"),
            filemode="a",
            format="%(asctime)s,%(msecs)d %(name)s %(levelname)s %(message)s",
            datefmt="%H:%M:%S",
            level=logging.DEBUG,
        )

    def _configure_spaces(self):
        # Define action and observation space
        self.max_mouse_move_x = self.display_size[0] // 2
        self.max_mouse_move_y = self.display_size[1] // 2
        self.action_space = gym.spaces.Dict(
            {
                "KEYS": gym.spaces.MultiBinary(len(KEY_MAP)),
                "MOUSE": gym.spaces.Box(
                    low=np.array([-self.max_mouse_move_x, -self.max_mouse_move_y]),
                    high=np.array([self.max_mouse_move_x, self.max_mouse_move_y]),
                    shape=(2,),
                    dtype=int,
                ),
            },
        )
        self.observation_space = gym.spaces.Box(
            0,
            255,
            shape=(self.display_size[1], self.display_size[0], 3),
            dtype=np.uint8,
        )

    def _set_artifact_dirs(self, artifact_dir, world_dir, config_path):
        if artifact_dir is None:
            self.artifact_dir = os.path.join(os.getcwd(), "artifacts")
        else:
            self.artifact_dir = artifact_dir

        if config_path is None:
            self.config_path = os.path.join(
                self.artifact_dir, f"{self.unique_env_id}.conf"
            )
        else:
            self.config_path = config_path

        if world_dir is None:
            self.reset_world = True
            self.world_dir = None
        else:
            self.reset_world = False
            self.world_dir = world_dir

        self.log_dir = os.path.join(self.artifact_dir, "log")
        logging.debug("logging to %s", self.log_dir)
        self.media_cache_dir = os.path.join(self.artifact_dir, "media_cache")

        os.makedirs(self.log_dir, exist_ok=True)
        os.makedirs(self.media_cache_dir, exist_ok=True)

    def _reset_zmq(self):
        if self.socket:
            self.socket.close()
        self.context = zmq.Context()
        self.socket = self.context.socket(zmq.REQ)
        self.socket.connect(f"tcp://{self.zmq_socket_addr}")

    def _reset_minetest(self):
        if not self.minetest_executable:
            logging.warning("Minetest executable not provided, reset is a no-op.")
            return None
        reset_timestamp = datetime.datetime.now().strftime("%m-%d-%Y,%H:%M:%S")
        log_path = os.path.join(
            self.log_dir,
            f"{{}}_{reset_timestamp}_{self.unique_env_id}.log",
        )

        if self.client_process:
            self.client_process.kill()

        self.client_process = self._start_minetest_client(
            log_path,
        )

    def _check_world_dir(self):
        if self.world_dir is None:
            raise RuntimeError(
                "World directory was not set. Please, provide a world directory "
                "in the constructor or seed the environment!",
            )

    def _delete_world(self):
        if self.world_dir and os.path.exists(self.world_dir):
            shutil.rmtree(self.world_dir, ignore_errors=True)

    def _check_config_path(self):
        if not self.config_path:
            raise RuntimeError(
                "Minetest config path was not set. Please, provide a config path "
                "in the constructor or seed the environment!",
            )

    def _delete_config(self):
        if os.path.exists(self.config_path):
            os.remove(self.config_path)

    def _write_config(self):
        config = dict(
            # Base config
            enable_sound=False,
            show_debug=False,
            enable_client_modding=True,
            csm_restriction_flags=0,
            enable_mod_channels=True,
            screen_w=self.display_size[0],
            screen_h=self.display_size[1],
            fov=self.fov_y,
            game_dir=self.game_dir,
            # Adapt HUD size to display size, based on (1024, 600) default
            hud_scaling=self.display_size[0] / 1024,
            # Attempt to improve performance. Impact unclear.
            server_map_save_interval=1000000,
            profiler_print_interval=0,
            active_block_range=2,
            abm_time_budget=0.01,
            abm_interval=0.1,
            active_block_mgmt_interval=4.0,
            server_unload_unused_data_timeout=1000000,
            client_unload_unused_data_timeout=1000000,
            full_block_send_enable_min_time_from_building=0.0,
            max_block_send_distance=100,
            max_block_generate_distance=100,
            num_emerge_threads=0,
            emergequeue_limit_total=1000000,
            emergequeue_limit_diskonly=1000000,
            emergequeue_limit_generate=1000000,
        )
        # Some games we carea bout currently use insecure lua features.
        config["secure.enable_security"] = False

        # Seed the map generator if not using a custom map
        if self.world_seed:
            config.update(fixed_map_seed=self.world_seed)
        # Update config from existing config file
        if os.path.exists(self.config_path):
            config.update(read_config_file(self.config_path))
        # Set from custom config dict
        config.update(self.config_dict)
        write_config_file(self.config_path, config)

    def _start_pygame(self):
        if pygame is None:
            raise ImportError(
                "pygame is required for rendering in human mode. "
                "Please install it: mamba install -c conda-forge pygame",
            )
        pygame.init()
        self.screen = pygame.display.set_mode(
            (self.display_size.width, self.display_size.height)
        )
        pygame.display.set_caption(f"Minetester - {self.unique_env_id}")

    def _display_pygame(self):
        # for some reason pydata expects the transposed image
        img_data = self.last_obs.transpose((1, 0, 2))

        # Convert the numpy array to a Pygame Surface and display it
        img = pygame.surfarray.make_surface(img_data)
        self.screen.blit(img, (0, 0))
        pygame.display.update()

    def seed(self, seed: Optional[int] = None):
        self._np_random = np.random.RandomState(seed or 0)

    def reset(
        self, seed: Optional[int] = None, options: Optional[Dict[str, Any]] = None
    ):
        self.seed(seed=seed)
        if self.reset_world:
            self._delete_world()
            if self.reseed_on_reset:
                self.world_seed = self._np_random.randint(np.iinfo(np.int64).max)
        self._reset_minetest()
        self._reset_zmq()

        empty_action_bytes = remoteclient_capnp.Action.new_message().to_bytes()
        # Annoyingly sometimes minetest returns observations but has not finished loading.
        valid_obs_max_attempts = 100
        # And sometimes it goes valid -> invalid -> valid.
        min_num_valid_obs = 3
        valid_obs_seen = 0
        logging.debug("Waiting for first obs...")
        for attempt in range(valid_obs_max_attempts):
            self.socket.send(empty_action_bytes)
            if not attempt:
                time.sleep(1)
                # Check for crash triggered by first action
                if self.client_process.poll() is not None:
                    raise RuntimeError(
                        "Minetest terminated during handshake! Return code: "
                        f"{self.client_process.returncode}, logs in {self.log_dir}",
                    )

            byte_obs = self.socket.recv()
            (
                obs,
                _,
                _,
            ) = deserialize_obs(byte_obs)
            if _is_loading(obs):
                valid_obs_seen = 0
                logging.debug(f"Still loading... {attempt}/{valid_obs_max_attempts}")
                continue
            valid_obs_seen += 1
            if valid_obs_seen >= min_num_valid_obs:
                logging.debug(f"Received first obs: {obs.shape}")
                self.last_obs = obs
                return obs, {}
        raise RuntimeError(
            f"Failed to get a valid observation after {valid_obs_max_attempts} attempts"
        )

    def step(self, action: Dict[str, Any]):
        if self.client_process and self.client_process.poll() is not None:
            raise RuntimeError(
                "Minetest terminated! Return code: "
                f"{self.client_process.returncode}, logs in {self.log_dir}",
            )

        # Send action
        if isinstance(action["MOUSE"], np.ndarray):
            action["MOUSE"] = action["MOUSE"].tolist()
        pb_action = serialize_action(action)
        logging.debug(f"Sending action: {pb_action}")
        self.socket.send(pb_action.to_bytes())

        # TODO more robust check for whether a server/client is alive while receiving observations
        if self.client_process and self.client_process.poll() is not None:
            return self.last_obs, 0.0, True, False, {}

        byte_obs = self.socket.recv()
        next_obs, rew, done = deserialize_obs(byte_obs)

        self.last_obs = next_obs
        logging.debug(f"Received obs - {next_obs.shape}; reward - {rew}")

        if self.render_mode == "human":
            self._display_pygame()

        return next_obs, rew, done, False, {}

    def render(self):
        if self.render_mode == "human":
            # rendering happens during step, as per gymnasium API
            return None
        return self.last_obs

    def close(self):
        if self.socket is not None:
            self.socket.close()
        if self.client_process:
            self.client_process.kill()
        if self.reset_world:
            self._delete_world()

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.close()

    def _start_minetest_client(
        self,
        log_path: str,
    ):
        cmd = [
            self.minetest_executable,
            "--go",  # skip menu
            "--config",
            self.config_path,
            "--remote-input",
            self.zmq_socket_addr,
        ]
        if self.headless:
            cmd.append("--headless")
        if self.verbose_logging:
            cmd.append("--verbose")
        if self.world_dir is not None:
            cmd.extend(["--world", self.world_dir])

        stdout_file = log_path.format("client_stdout")
        stderr_file = log_path.format("client_stderr")
        with open(stdout_file, "w") as out, open(stderr_file, "w") as err:
            client_env = os.environ.copy()
            # Avoids error in logs about missing XDG_RUNTIME_DIR
            client_env["XDG_RUNTIME_DIR"] = self.artifact_dir
            # enable GPU usage
            # TODO: should probably check for NVidia GPU before doing this.
            client_env["__GLX_VENDOR_LIBRARY_NAME"] = "indirect"  # "nvidia"
            client_env["__NV_PRIME_RENDER_OFFLOAD"] = "1"
            # disable vsync
            client_env["__GL_SYNC_TO_VBLANK"] = "0"
            client_env["vblank_mode"] = "0"
            out.write(
                f"Starting client with command: {' '.join(str(x) for x in cmd)}\n"
            )
            out.write(f"Client environment: {client_env}\n")
            client_process = subprocess.Popen(
                cmd, stdout=out, stderr=err, env=client_env
            )
            out.write(f"Client started with pid {client_process.pid}\n")
        logging.debug(f"Client started with pid {client_process.pid}")
        return client_process


def deserialize_obs(received_obs: bytes):
    with remoteclient_capnp.Observation.from_bytes(received_obs) as obs_msg:
        # Convert the response to a numpy array
        img = obs_msg.image
        img_data = np.frombuffer(img.data, dtype=np.uint8).reshape(
            (img.height, img.width, 3)
        )
        # Reshape the numpy array to the correct dimensions
        reward = obs_msg.reward
        done = obs_msg.done
    return img_data, reward, done


def serialize_action(action: Dict[str, Any]):
    action_msg = remoteclient_capnp.Action.new_message()

    action_msg.mouseDx = action["MOUSE"][0]
    action_msg.mouseDy = action["MOUSE"][1]

    keyEvents = action_msg.init("keyEvents", action["KEYS"].sum())
    setIdx = 0
    for idx, pressed in enumerate(action["KEYS"]):
        if pressed:
            keyEvents[setIdx] = KEY_MAP[idx]
            setIdx += 1
    return action_msg


# Python impl of Minetest's config file parser in main.cpp:read_config_file
# https://github.com/Astera-org/minetest/blob/b18fb18138c3ec658d9fef9fc84b085a7f4f9a01/src/main.cpp#L731
def read_config_file(file_path):
    config = {}
    with open(file_path) as f:
        for line in f:
            line = line.strip()
            if line and not line.startswith("#"):
                key, value = line.split("=", 1)
                key = key.strip()
                value = value.strip()
                if value.isdigit():
                    value = int(value)
                elif value.replace(".", "", 1).isdigit():
                    value = float(value)
                elif value.lower() == "true":
                    value = True
                elif value.lower() == "false":
                    value = False
                config[key] = value
    return config


def write_config_file(file_path, config):
    with open(file_path, "w") as f:
        for key, value in config.items():
            f.write(f"{key} = {value}\n")


# take a lucky guess at a free port
# this works by having the OS return a free port, then immediately closing the socket
# not guaranteed to be free, but should be good enough for our purposes
def get_free_port():
    s = socket.socket()
    s.bind(("", 0))
    port = s.getsockname()[1]
    s.close()
    return port
